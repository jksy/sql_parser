module OracleSqlParser::Grammar
  grammar Condition
    # where
    rule where_clause
      where_keyword space? logical_condition {
        def ast
          OracleSqlParser::Ast::WhereClause[:condition => logical_condition.ast]
        end
      }
    end

    rule condition
      comparision_condition /
      floating_point_condition /
      model_condition /
      mutiset_condition /
      pattern_maching_condition /
      null_condition /
      xml_condition /
      compound_condition /
      between_condition /
      exists_condition /
      in_condition /
      is_of_type_condition {
          def ast
            super
          end
        }
    end

    rule logical_condition
      (
        op:not_keyword space? right:condition /
        left:condition space? op:and_keyword space? right:condition /
        left:condition space? op:or_keyword space? right:condition  /
        cond:condition
      ) {
        def ast
          if respond_to? :op
            if respond_to? :left
              OracleSqlParser::Ast::LogicalCondition[
                :left => left.ast,
                :op => op.ast,
                :right => right.ast]
            else
              OracleSqlParser::Ast::LogicalCondition[
                :op => op.ast,
                :right => right.ast]
            end
          else
            cond.ast
          end
        end
      }
    end

    rule comparision_condition
      (
        simple_comparision_condition /
        group_comparision_condition
      ) {
        def ast
          super
        end
      }
    end

    rule group_comparision_condition
      'group_comparision_condition'
    end

    rule simple_comparision_condition
      (
        left:expr space? op:('!=' / '^=' / '<>' / '>=' / '<=' / '=' / '>' / '<') space? right:expr /
        '(' space? left:exprs space? ')' op:space? ('!=' / '^=' / '<>' / '=') space? '(' space? right:subquery space? ')'
      ) {
        def ast
          OracleSqlParser::Ast::SimpleComparisionCondition[
            :left => left.ast,
            :op => op.text_value,
            :right => right.ast]
        end
      }
    end

    rule floating_point_condition
      expr space? is_keyword space? not_keyword:not_keyword? space?
      value:(
        nan_keyword /
        infinite_keyword
      ) {
        def ast
          OracleSqlParser::Ast::FloatingPointCondition[
            :target => expr.ast,
            :is => is_keyword.ast,
            :not => not_keyword.ast,
            :value => value.ast
          ]
        end
      }
    end

    rule model_condition
      'model_condition'
    end

    rule mutiset_condition
      is_a_set_condition /
      is_empty_condition /
      member_condition /
      submultiset_condition {
        def ast
          super
        end
      }
    end

    rule nested_table
      ident {
        def ast
          super
        end
      }
    end

    rule is_a_set_condition
      nested_table space? is_keyword space? not_keyword:not_keyword? space? a:[Aa] space? set_keyword {
        def ast
          OracleSqlParser::Ast::IsASetCondition[
            :target => nested_table.ast,
            :is => is_keyword.ast,
            :not => not_keyword.ast,
            :a => OracleSqlParser::Ast::Keyword[:name => a.text_value],
            :set => set_keyword.ast
          ]
        end
      }
    end

    rule is_empty_condition
      nested_table space? is_keyword space? not_keyword:not_keyword? space? empty_keyword {
        def ast
          OracleSqlParser::Ast::IsEmptyCondition[
            :target => nested_table.ast,
            :is => is_keyword.ast,
            :not => not_keyword.ast,
            :empty => empty_keyword.ast
          ]
        end
      }
    end

    rule member_condition
      expr space? not_keyword:not_keyword? space? member_keyword space? of_keyword space? nested_table {
        def ast
          OracleSqlParser::Ast::MemberCondition[
            :target => expr.ast,
            :not => not_keyword.ast,
            :member => member_keyword.ast,
            :of => of_keyword.ast,
            :table => nested_table.ast
          ]
        end
      }
    end

    rule submultiset_condition
      table1:nested_table space?
      not_keyword:not_keyword? space?
      submultiset_keyword space?
      of_keyword:of_keyword? space?
      table2:nested_table {
        def ast
          OracleSqlParser::Ast::SubmultisetCondition[
            :target => table1.ast,
            :not => not_keyword.ast,
            :submultiset => submultiset_keyword.ast,
            :of => of_keyword.ast,
            :table => table2.ast
          ]
        end
      }
    end

    rule pattern_maching_condition
      (
        like_condition /
        regexp_like_condition
      ) {
        def ast
          super
        end
      }
    end

    rule like_condition
      target:ident space
      n:(not_keyword:not_keyword space)?
      like:(like_keyword / like2_keyword / like4_keyword / likec_keyword) space
      text:text_literal
      e:(space escape_keyword space escape_text:text_literal)? {
        def ast
          OracleSqlParser::Ast::LikeCondition[
            :target => target.ast,
            :not => not_keyword.ast,
            :like => like.ast,
            :text => text.ast,
            :escape => escape_text.ast]
        end

        def not_keyword
          n.elements && n.elements.first
        end

        def escape_text
          if e.respond_to? :escape_text
            e.escape_text
          end
        end
      }
    end

    rule regexp_like_condition
      regexp_like_keyword '(' space? target:ident space? ',' space? regexp:text_literal space? ')' {
        def ast
          OracleSqlParser::Ast::RegexpCondition[
            :target => target.ast,
            :regexp => regexp.ast]
        end
      }
    end

    rule null_condition
      expr space is_keyword space n:(not_keyword space)? null_keyword {
        def ast
          OracleSqlParser::Ast::NullCondition[
            :target => expr.ast,
            :not => not_keyword.ast]
        end

        def not_keyword
          n.elements && n.elements.first
        end
      }
    end

    rule xml_condition
      'xml_condition'
    end

    rule compound_condition
      '(' logical_condition ')' {
        def ast
          OracleSqlParser::Ast::CompoundCondition[:condition => logical_condition.ast]
        end
      }
    end

    rule between_condition
      target:expr space n:(not_keyword space)? between_keyword space from:expr space and_keyword space to:expr {
        def ast
          OracleSqlParser::Ast::BetweenCondition[
            :target => target.ast,
            :not => not_keyword.ast,
            :from => from.ast,
            :to => to.ast
          ]
        end

        def not_keyword
          n.elements && n.elements.first
        end
      }
    end

    rule exists_condition
      exists_keyword space? '(' space? subquery space? ')' {
        def ast
          OracleSqlParser::Ast::ExistsCondition[
            :target => subquery.ast
          ]
        end
      }
    end

    rule in_condition
      target:expr space n:(not_keyword space)? in_keyword space? '(' space? values:( exprs / subquery ) space? ')' {
        def ast
          OracleSqlParser::Ast::InCondition[
            :target => target.ast,
            :not => not_keyword.ast,
            :values =>  values.ast
          ]
        end

        def not_keyword
          n.elements && n.elements.first
        end
      }
    end

    rule is_of_type_condition
      expr space?
      is_keyword space?
      not_keyword:not_keyword? space?
      of_keyword space?
      type_keyword:type_keyword? space?
      '(' space? types space? ')' {
        def ast
          OracleSqlParser::Ast::IsOfTypeCondition[
            :target => expr.ast,
            :is => is_keyword.ast,
            :not => not_keyword.ast,
            :of => of_keyword.ast,
            :type => type_keyword.ast,
            :types => types.ast
          ]
        end
      }
    end

    rule types
      only_and_type space? more:(',' space? only_and_type space?)* {
        def ast
          OracleSqlParser::Ast::Array[only_and_type.ast, *more_only_and_types.map(&:ast)]
        end

        def more_only_and_types
          more.elements.map(&:only_and_type)
        end
      }
    end

    rule only_and_type
      only_keyword:only_keyword? space? type {
        def ast
          OracleSqlParser::Ast::OnlyAndType[
            :only => only_keyword.ast,
            :type => type.ast
          ]
        end
      }
    end

    rule type
      schema_name '.' ident /
      ident {
        def ast
          OracleSqlParser::Ast::Identifier[:name => text_value]
        end
      }
    end
  end
end
