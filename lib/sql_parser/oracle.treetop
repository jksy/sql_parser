module SqlParser
  grammar Oracle
    include OracleReservedWord
    rule sql 
      space? q:select_query {
        def ast
          q.ast
        end
      }
    end

    rule select_query
      subquery for_update_clause? {
        def ast
          subquery.ast
        end
      }
    end

    rule subquery
      query_block 
      order_by_clause:order_by_clause? {
        def ast
          query_block.ast
        end
      }
      # subquery union subquery order_by_clause_or_empty       not implemented rules 
      # subquery INTERSECT subquery order_by_clause_or_empty
      # subquery MINUS subquery order_by_clause_or_empty
    end

    rule query_block 
      subquery_factoring_clause? space?
      select_keyword 
      hint? 
      all_keyword? space?
      select_list space? 
      from_keyword space?
      select_sources space?
      where_clause? space?
      group_by_clause? space?
      model_clause? space?
    end

    rule ident
      !keyword [a-zA-Z] [a-zA-Z0-9]* <Identifier>
    end

    rule space
      ' '+ 
    end

    rule for_update_clause
      'for_update_clause' { # not implemented
      }
    end

    rule subquery_factoring_clause
      'subquery_factoring_clause' { # not implemented
      }
    end

    rule order_by_clause
      'order_by_clause'  { # not implemented
      }
    end

    rule hint # not implemented
      '/*+' '*/' {
        def ast
          nil
        end
      }
    end

    rule select_list
      select_one_column more_list:( space? ',' space? c:select_one_column space? )* {
        def ast
          [select_one_column, *more_columns].flatten
        end

        def more_columns
          more_list.elements.map(&:c)
        end
      }
    end

    rule select_one_column
      ( select_table /
        select_column /
        expr ) {
          def ast
            self.elements.first
          end
        }
    end

    rule select_table
      (table_name '.')? '*' <Identifier>
    end

    rule select_column
      expr ( space ( as_keyword space )? c_alias )?  {
        def ast
          [expr, as, c_alias]
        end
      }
    end

    rule t_alias
      ident
    end

    rule c_alias
      ident
    end

    rule expr
      ident / text_literal / number_literal
    end

    rule exprs
      expr (space? ',' space? expr)*
    end

    rule expression_list
      ('(' exprs ')' / exprs)
    end

    rule table_name
      ident
    end

    rule column_name
      ident
    end

    rule schema_name
      ident
    end

    rule select_sources
      ident 
    end

    rule number_literal
      '-'? [0-9]+ ([.] [0-9]+)? <NumberLiteral>
    end

    rule text_literal
      "'" ("\\'" / !"'" .)* "'" <TextLiteral>
    end

    # where
    rule where_clause
      where_keyword space? logical_condition
    end

    rule condition
      (
        comparision_condition /
        floating_point_condition /
        model_condition /
        mutiset_condition /
        pattern_maching_condition /
        range_condition /
        null_condition /
        xml_condition /
        compound_condition /
        between_condition /
        exists_condition /
        in_condition /
        is_of_type_condition
      )
    end

    rule logical_condition
      left:condition space? and_keyword space? right:condition /
      left:condition space? or_keyword space? right:condition  /
      not_keyword space? right:condition /
      condition
    end

    rule comparision_condition
      (
        simple_comparision_conditions /
        group_comparision_conditions
      )
    end

    rule group_comparision_conditions
      'group_comparision_conditions'
    end

    rule simple_comparision_conditions
      (
        left:expr space? ('!=' / '^=' / '<>' / '>=' / '<=' / '=' / '>' / '<') space? right:expr /
        '(' space? left:exprs space? ')' space? ('!=' / '^=' / '<>' / '=') space? '(' space? right:subquery space? ')'
      )
    end

    rule floating_point_condition 
      'floating_point_condition'
    end

    rule model_condition
      'model_condition'
    end

    rule mutiset_condition 
      'mutiset_condition'
    end
    
    rule pattern_maching_condition 
      (
        like_condition /
        regexp_like_condition
      )
    end

    rule like_condition
      ident space
      (not_keyword space)?
      (like_keyword / like2_keyword / like4_keyword / likec_keyword) space
      text_literal
      (space escape_keyword space text_literal)?
    end

    rule regexp_like_condition
      regexp_like_keyword '(' space? ident space? ',' space? text_literal space? ')'
    end

    rule range_condition 
      'range_condition'
    end
    
    rule null_condition 
      expr space is_keyword space (not_keyword space)? null_keyword
    end
    rule xml_condition 
      'xml_condition'
    end

    rule compound_condition 
      '(' logical_condition ')'
    end

    rule between_condition 
      expr space (not_keyword space)? between_keyword space expr space and_keyword space expr
    end

    rule exists_condition 
      exists_keyword space? '(' space? subquery space? ')'
    end

    rule in_condition 
      expr space (not_keyword space)? in_keyword space? '(' space? ( exprs / subquery ) space? ')'
    end

    rule is_of_type_condition 
      'is_of_type_condition'
    end


    # group
    rule group_by_clause
      group_keyword space by_keyword space (( expr / rollup_cube_clause / grouping_sets_clause) space?)
        (',' space? ((expr  / rollup_cube_clause / grouping_sets_clause) space?))*
      (having_keyword space condition)?
    end

    rule rollup_cube_clause
      (rollup_keyword / cube_keyword) space? '(' space? grouping_expression_list space? ')'
    end

    rule grouping_sets_clause
      'grouping_sets_clause' # not implemented
    end

    rule grouping_expression_list
      expression_list (',' expression_list)*
    end

    rule model_clause
      'model_clause'
    end
  end
end
