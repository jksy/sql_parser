#
# Autogenerated from a Treetop grammar. Edits may be lost.


# oracle_reserved_word.treetop generated by lib/sql_parser/oracle_reserved_word_generator.rb at 2015-07-07 15:39:39 +0000
#
module SqlParser
  module OracleReservedWord
    include Treetop::Runtime

    def root
      @root ||= :keyword
    end

    module Keyword0
    end

    def _nt_keyword
      start_index = index
      if node_cache[:keyword].has_key?(index)
        cached = node_cache[:keyword][index]
        if cached
          node_cache[:keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      s1, i1 = [], index
      loop do
        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9_]')
          r2 = nil
        end
        if r2
          s1 << r2
        else
          break
        end
      end
      if s1.empty?
        @index = i1
        r1 = nil
      else
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      end
      s0 << r1
      if r1
        i3 = index
        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
          r4 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9]')
          r4 = nil
        end
        if r4
          @index = i3
          r3 = nil
          terminal_parse_failure('[a-zA-Z0-9]', true)
        else
          terminal_failures.pop
          @index = i3
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          i5 = index
          r6 = lambda {|w| ["ACCESS", "ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUDIT", "BETWEEN", "BY", "CHAR", "CHECK", "CLUSTER", "COLUMN", "COLUMN_VALUE", "COMMENT", "COMPRESS", "CONNECT", "CREATE", "CURRENT", "DATE", "DECIMAL", "DEFAULT", "DELETE", "DESC", "DISTINCT", "DROP", "ELSE", "ESCAPE", "EXCLUSIVE", "EXISTS", "FILE", "FLOAT", "FOR", "FROM", "GRANT", "GROUP", "HAVING", "IDENTIFIED", "IMMEDIATE", "IN", "INCREMENT", "INDEX", "INITIAL", "INSERT", "INTEGER", "INTERSECT", "INTO", "IS", "LEVEL", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LOCK", "LONG", "MAXEXTENTS", "MINUS", "MLSLABEL", "MODE", "MODIFY", "NESTED_TABLE_ID", "NOAUDIT", "NOCOMPRESS", "NOT", "NOWAIT", "NULL", "NUMBER", "OF", "OFFLINE", "ON", "ONLINE", "OPTION", "OR", "ORDER", "PCTFREE", "PRIOR", "PRIVILEGES", "PUBLIC", "RAW", "REGEXP_LIKE", "RENAME", "RESOURCE", "REVOKE", "ROW", "ROWID", "ROWNUM", "ROWS", "SELECT", "SESSION", "SET", "SHARE", "SIZE", "SMALLINT", "START", "SUCCESSFUL", "SYNONYM", "SYSDATE", "TABLE", "THEN", "TO", "TRIGGER", "UID", "UNION", "UNIQUE", "UPDATE", "USER", "VALIDATE", "VALUES", "VARCHAR", "VARCHAR2", "VIEW", "WHENEVER", "WHERE"].include? w.first.text_value.upcase}.call(s0)
          if !r6
            terminal_parse_failure("<semantic predicate>")
          end
          if r6
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          else
            @index = i5
            r5 = nil
          end
          s0 << r5
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Keyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:keyword][start_index] = r0

      r0
    end

    module AccessKeyword0
    end

    def _nt_access_keyword
      start_index = index
      if node_cache[:access_keyword].has_key?(index)
        cached = node_cache[:access_keyword][index]
        if cached
          node_cache[:access_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[cC]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[sS]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AccessKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:access_keyword][start_index] = r0

      r0
    end

    module AddKeyword0
    end

    def _nt_add_keyword
      start_index = index
      if node_cache[:add_keyword].has_key?(index)
        cached = node_cache[:add_keyword][index]
        if cached
          node_cache[:add_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[dD]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AddKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:add_keyword][start_index] = r0

      r0
    end

    module AllKeyword0
    end

    def _nt_all_keyword
      start_index = index
      if node_cache[:all_keyword].has_key?(index)
        cached = node_cache[:all_keyword][index]
        if cached
          node_cache[:all_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AllKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:all_keyword][start_index] = r0

      r0
    end

    module AlterKeyword0
    end

    def _nt_alter_keyword
      start_index = index
      if node_cache[:alter_keyword].has_key?(index)
        cached = node_cache[:alter_keyword][index]
        if cached
          node_cache[:alter_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AlterKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:alter_keyword][start_index] = r0

      r0
    end

    module AndKeyword0
    end

    def _nt_and_keyword
      start_index = index
      if node_cache[:and_keyword].has_key?(index)
        cached = node_cache[:and_keyword][index]
        if cached
          node_cache[:and_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AndKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:and_keyword][start_index] = r0

      r0
    end

    module AnyKeyword0
    end

    def _nt_any_keyword
      start_index = index
      if node_cache[:any_keyword].has_key?(index)
        cached = node_cache[:any_keyword][index]
        if cached
          node_cache[:any_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[yY]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AnyKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:any_keyword][start_index] = r0

      r0
    end

    module AsKeyword0
    end

    def _nt_as_keyword
      start_index = index
      if node_cache[:as_keyword].has_key?(index)
        cached = node_cache[:as_keyword][index]
        if cached
          node_cache[:as_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[sS]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AsKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:as_keyword][start_index] = r0

      r0
    end

    module AscKeyword0
    end

    def _nt_asc_keyword
      start_index = index
      if node_cache[:asc_keyword].has_key?(index)
        cached = node_cache[:asc_keyword][index]
        if cached
          node_cache[:asc_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[sS]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AscKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:asc_keyword][start_index] = r0

      r0
    end

    module AuditKeyword0
    end

    def _nt_audit_keyword
      start_index = index
      if node_cache[:audit_keyword].has_key?(index)
        cached = node_cache[:audit_keyword][index]
        if cached
          node_cache[:audit_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[aA]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(AuditKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:audit_keyword][start_index] = r0

      r0
    end

    module BetweenKeyword0
    end

    def _nt_between_keyword
      start_index = index
      if node_cache[:between_keyword].has_key?(index)
        cached = node_cache[:between_keyword][index]
        if cached
          node_cache[:between_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[bB]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[wW]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[nN]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(BetweenKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:between_keyword][start_index] = r0

      r0
    end

    module ByKeyword0
    end

    def _nt_by_keyword
      start_index = index
      if node_cache[:by_keyword].has_key?(index)
        cached = node_cache[:by_keyword][index]
        if cached
          node_cache[:by_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[bB]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[yY]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ByKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:by_keyword][start_index] = r0

      r0
    end

    module CharKeyword0
    end

    def _nt_char_keyword
      start_index = index
      if node_cache[:char_keyword].has_key?(index)
        cached = node_cache[:char_keyword][index]
        if cached
          node_cache[:char_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CharKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:char_keyword][start_index] = r0

      r0
    end

    module CheckKeyword0
    end

    def _nt_check_keyword
      start_index = index
      if node_cache[:check_keyword].has_key?(index)
        cached = node_cache[:check_keyword][index]
        if cached
          node_cache[:check_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[cC]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[kK]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CheckKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:check_keyword][start_index] = r0

      r0
    end

    module ClusterKeyword0
    end

    def _nt_cluster_keyword
      start_index = index
      if node_cache[:cluster_keyword].has_key?(index)
        cached = node_cache[:cluster_keyword][index]
        if cached
          node_cache[:cluster_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[uU]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[sS]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ClusterKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:cluster_keyword][start_index] = r0

      r0
    end

    module ColumnKeyword0
    end

    def _nt_column_keyword
      start_index = index
      if node_cache[:column_keyword].has_key?(index)
        cached = node_cache[:column_keyword][index]
        if cached
          node_cache[:column_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ColumnKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:column_keyword][start_index] = r0

      r0
    end

    module ColumnValueKeyword0
    end

    def _nt_column_value_keyword
      start_index = index
      if node_cache[:column_value_keyword].has_key?(index)
        cached = node_cache[:column_value_keyword][index]
        if cached
          node_cache[:column_value_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if (match_len = has_terminal?('_', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'_\'')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[vV]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[aA]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[lL]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                            r11 = true
                            @index += 1
                          else
                            terminal_parse_failure('[uU]')
                            r11 = nil
                          end
                          s0 << r11
                          if r11
                            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                              r12 = true
                              @index += 1
                            else
                              terminal_parse_failure('[eE]')
                              r12 = nil
                            end
                            s0 << r12
                            if r12
                              i13 = index
                              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                                r14 = true
                                @index += 1
                              else
                                terminal_parse_failure('[A-Za-z0-9]')
                                r14 = nil
                              end
                              if r14
                                @index = i13
                                r13 = nil
                                terminal_parse_failure('[A-Za-z0-9]', true)
                              else
                                terminal_failures.pop
                                @index = i13
                                r13 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s0 << r13
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ColumnValueKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:column_value_keyword][start_index] = r0

      r0
    end

    module CommentKeyword0
    end

    def _nt_comment_keyword
      start_index = index
      if node_cache[:comment_keyword].has_key?(index)
        cached = node_cache[:comment_keyword][index]
        if cached
          node_cache[:comment_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[mM]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[mM]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CommentKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:comment_keyword][start_index] = r0

      r0
    end

    module CompressKeyword0
    end

    def _nt_compress_keyword
      start_index = index
      if node_cache[:compress_keyword].has_key?(index)
        cached = node_cache[:compress_keyword][index]
        if cached
          node_cache[:compress_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[mM]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[pP]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[sS]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[sS]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CompressKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:compress_keyword][start_index] = r0

      r0
    end

    module ConnectKeyword0
    end

    def _nt_connect_keyword
      start_index = index
      if node_cache[:connect_keyword].has_key?(index)
        cached = node_cache[:connect_keyword][index]
        if cached
          node_cache[:connect_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[nN]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[cC]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ConnectKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:connect_keyword][start_index] = r0

      r0
    end

    module CreateKeyword0
    end

    def _nt_create_keyword
      start_index = index
      if node_cache[:create_keyword].has_key?(index)
        cached = node_cache[:create_keyword][index]
        if cached
          node_cache[:create_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CreateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:create_keyword][start_index] = r0

      r0
    end

    module CurrentKeyword0
    end

    def _nt_current_keyword
      start_index = index
      if node_cache[:current_keyword].has_key?(index)
        cached = node_cache[:current_keyword][index]
        if cached
          node_cache[:current_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[cC]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[rR]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(CurrentKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:current_keyword][start_index] = r0

      r0
    end

    module DateKeyword0
    end

    def _nt_date_keyword
      start_index = index
      if node_cache[:date_keyword].has_key?(index)
        cached = node_cache[:date_keyword][index]
        if cached
          node_cache[:date_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:date_keyword][start_index] = r0

      r0
    end

    module DecimalKeyword0
    end

    def _nt_decimal_keyword
      start_index = index
      if node_cache[:decimal_keyword].has_key?(index)
        cached = node_cache[:decimal_keyword][index]
        if cached
          node_cache[:decimal_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[aA]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[lL]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DecimalKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:decimal_keyword][start_index] = r0

      r0
    end

    module DefaultKeyword0
    end

    def _nt_default_keyword
      start_index = index
      if node_cache[:default_keyword].has_key?(index)
        cached = node_cache[:default_keyword][index]
        if cached
          node_cache[:default_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[fF]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[uU]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[lL]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DefaultKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:default_keyword][start_index] = r0

      r0
    end

    module DeleteKeyword0
    end

    def _nt_delete_keyword
      start_index = index
      if node_cache[:delete_keyword].has_key?(index)
        cached = node_cache[:delete_keyword][index]
        if cached
          node_cache[:delete_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DeleteKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:delete_keyword][start_index] = r0

      r0
    end

    module DescKeyword0
    end

    def _nt_desc_keyword
      start_index = index
      if node_cache[:desc_keyword].has_key?(index)
        cached = node_cache[:desc_keyword][index]
        if cached
          node_cache[:desc_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[cC]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DescKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:desc_keyword][start_index] = r0

      r0
    end

    module DistinctKeyword0
    end

    def _nt_distinct_keyword
      start_index = index
      if node_cache[:distinct_keyword].has_key?(index)
        cached = node_cache[:distinct_keyword][index]
        if cached
          node_cache[:distinct_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[tT]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[cC]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[tT]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DistinctKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:distinct_keyword][start_index] = r0

      r0
    end

    module DropKeyword0
    end

    def _nt_drop_keyword
      start_index = index
      if node_cache[:drop_keyword].has_key?(index)
        cached = node_cache[:drop_keyword][index]
        if cached
          node_cache[:drop_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[dD]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[oO]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[pP]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(DropKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:drop_keyword][start_index] = r0

      r0
    end

    module ElseKeyword0
    end

    def _nt_else_keyword
      start_index = index
      if node_cache[:else_keyword].has_key?(index)
        cached = node_cache[:else_keyword][index]
        if cached
          node_cache[:else_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[eE]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ElseKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:else_keyword][start_index] = r0

      r0
    end

    module EscapeKeyword0
    end

    def _nt_escape_keyword
      start_index = index
      if node_cache[:escape_keyword].has_key?(index)
        cached = node_cache[:escape_keyword][index]
        if cached
          node_cache[:escape_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[eE]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[sS]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[pP]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(EscapeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escape_keyword][start_index] = r0

      r0
    end

    module ExclusiveKeyword0
    end

    def _nt_exclusive_keyword
      start_index = index
      if node_cache[:exclusive_keyword].has_key?(index)
        cached = node_cache[:exclusive_keyword][index]
        if cached
          node_cache[:exclusive_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[eE]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[xX]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[uU]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[iI]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[vV]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[eE]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        i10 = index
                        if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r11 = true
                          @index += 1
                        else
                          terminal_parse_failure('[A-Za-z0-9]')
                          r11 = nil
                        end
                        if r11
                          @index = i10
                          r10 = nil
                          terminal_parse_failure('[A-Za-z0-9]', true)
                        else
                          terminal_failures.pop
                          @index = i10
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r10
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ExclusiveKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:exclusive_keyword][start_index] = r0

      r0
    end

    module ExistsKeyword0
    end

    def _nt_exists_keyword
      start_index = index
      if node_cache[:exists_keyword].has_key?(index)
        cached = node_cache[:exists_keyword][index]
        if cached
          node_cache[:exists_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[eE]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[xX]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[sS]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ExistsKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:exists_keyword][start_index] = r0

      r0
    end

    module FileKeyword0
    end

    def _nt_file_keyword
      start_index = index
      if node_cache[:file_keyword].has_key?(index)
        cached = node_cache[:file_keyword][index]
        if cached
          node_cache[:file_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[fF]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(FileKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:file_keyword][start_index] = r0

      r0
    end

    module FloatKeyword0
    end

    def _nt_float_keyword
      start_index = index
      if node_cache[:float_keyword].has_key?(index)
        cached = node_cache[:float_keyword][index]
        if cached
          node_cache[:float_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[fF]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[oO]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(FloatKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:float_keyword][start_index] = r0

      r0
    end

    module ForKeyword0
    end

    def _nt_for_keyword
      start_index = index
      if node_cache[:for_keyword].has_key?(index)
        cached = node_cache[:for_keyword][index]
        if cached
          node_cache[:for_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[fF]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[rR]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ForKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:for_keyword][start_index] = r0

      r0
    end

    module FromKeyword0
    end

    def _nt_from_keyword
      start_index = index
      if node_cache[:from_keyword].has_key?(index)
        cached = node_cache[:from_keyword][index]
        if cached
          node_cache[:from_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[fF]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[oO]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[mM]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(FromKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:from_keyword][start_index] = r0

      r0
    end

    module GrantKeyword0
    end

    def _nt_grant_keyword
      start_index = index
      if node_cache[:grant_keyword].has_key?(index)
        cached = node_cache[:grant_keyword][index]
        if cached
          node_cache[:grant_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[gG]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(GrantKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:grant_keyword][start_index] = r0

      r0
    end

    module GroupKeyword0
    end

    def _nt_group_keyword
      start_index = index
      if node_cache[:group_keyword].has_key?(index)
        cached = node_cache[:group_keyword][index]
        if cached
          node_cache[:group_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[gG]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[oO]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[pP]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(GroupKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:group_keyword][start_index] = r0

      r0
    end

    module HavingKeyword0
    end

    def _nt_having_keyword
      start_index = index
      if node_cache[:having_keyword].has_key?(index)
        cached = node_cache[:having_keyword][index]
        if cached
          node_cache[:having_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[hH]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[vV]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[nN]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[gG]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(HavingKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:having_keyword][start_index] = r0

      r0
    end

    module IdentifiedKeyword0
    end

    def _nt_identified_keyword
      start_index = index
      if node_cache[:identified_keyword].has_key?(index)
        cached = node_cache[:identified_keyword][index]
        if cached
          node_cache[:identified_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[dD]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[iI]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[fF]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[iI]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[eE]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[dD]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          i11 = index
                          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[A-Za-z0-9]')
                            r12 = nil
                          end
                          if r12
                            @index = i11
                            r11 = nil
                            terminal_parse_failure('[A-Za-z0-9]', true)
                          else
                            terminal_failures.pop
                            @index = i11
                            r11 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IdentifiedKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:identified_keyword][start_index] = r0

      r0
    end

    module ImmediateKeyword0
    end

    def _nt_immediate_keyword
      start_index = index
      if node_cache[:immediate_keyword].has_key?(index)
        cached = node_cache[:immediate_keyword][index]
        if cached
          node_cache[:immediate_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[mM]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[mM]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[dD]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[iI]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[aA]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[tT]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[eE]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        i10 = index
                        if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r11 = true
                          @index += 1
                        else
                          terminal_parse_failure('[A-Za-z0-9]')
                          r11 = nil
                        end
                        if r11
                          @index = i10
                          r10 = nil
                          terminal_parse_failure('[A-Za-z0-9]', true)
                        else
                          terminal_failures.pop
                          @index = i10
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r10
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ImmediateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:immediate_keyword][start_index] = r0

      r0
    end

    module InKeyword0
    end

    def _nt_in_keyword
      start_index = index
      if node_cache[:in_keyword].has_key?(index)
        cached = node_cache[:in_keyword][index]
        if cached
          node_cache[:in_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(InKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:in_keyword][start_index] = r0

      r0
    end

    module IncrementKeyword0
    end

    def _nt_increment_keyword
      start_index = index
      if node_cache[:increment_keyword].has_key?(index)
        cached = node_cache[:increment_keyword][index]
        if cached
          node_cache[:increment_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[mM]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[nN]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[tT]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        i10 = index
                        if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r11 = true
                          @index += 1
                        else
                          terminal_parse_failure('[A-Za-z0-9]')
                          r11 = nil
                        end
                        if r11
                          @index = i10
                          r10 = nil
                          terminal_parse_failure('[A-Za-z0-9]', true)
                        else
                          terminal_failures.pop
                          @index = i10
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r10
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IncrementKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:increment_keyword][start_index] = r0

      r0
    end

    module IndexKeyword0
    end

    def _nt_index_keyword
      start_index = index
      if node_cache[:index_keyword].has_key?(index)
        cached = node_cache[:index_keyword][index]
        if cached
          node_cache[:index_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[xX]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IndexKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:index_keyword][start_index] = r0

      r0
    end

    module InitialKeyword0
    end

    def _nt_initial_keyword
      start_index = index
      if node_cache[:initial_keyword].has_key?(index)
        cached = node_cache[:initial_keyword][index]
        if cached
          node_cache[:initial_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[tT]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[aA]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[lL]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(InitialKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:initial_keyword][start_index] = r0

      r0
    end

    module InsertKeyword0
    end

    def _nt_insert_keyword
      start_index = index
      if node_cache[:insert_keyword].has_key?(index)
        cached = node_cache[:insert_keyword][index]
        if cached
          node_cache[:insert_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[tT]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(InsertKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:insert_keyword][start_index] = r0

      r0
    end

    module IntegerKeyword0
    end

    def _nt_integer_keyword
      start_index = index
      if node_cache[:integer_keyword].has_key?(index)
        cached = node_cache[:integer_keyword][index]
        if cached
          node_cache[:integer_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[gG]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IntegerKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:integer_keyword][start_index] = r0

      r0
    end

    module IntersectKeyword0
    end

    def _nt_intersect_keyword
      start_index = index
      if node_cache[:intersect_keyword].has_key?(index)
        cached = node_cache[:intersect_keyword][index]
        if cached
          node_cache[:intersect_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[cC]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[tT]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        i10 = index
                        if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r11 = true
                          @index += 1
                        else
                          terminal_parse_failure('[A-Za-z0-9]')
                          r11 = nil
                        end
                        if r11
                          @index = i10
                          r10 = nil
                          terminal_parse_failure('[A-Za-z0-9]', true)
                        else
                          terminal_failures.pop
                          @index = i10
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r10
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IntersectKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:intersect_keyword][start_index] = r0

      r0
    end

    module IntoKeyword0
    end

    def _nt_into_keyword
      start_index = index
      if node_cache[:into_keyword].has_key?(index)
        cached = node_cache[:into_keyword][index]
        if cached
          node_cache[:into_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IntoKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:into_keyword][start_index] = r0

      r0
    end

    module IsKeyword0
    end

    def _nt_is_keyword
      start_index = index
      if node_cache[:is_keyword].has_key?(index)
        cached = node_cache[:is_keyword][index]
        if cached
          node_cache[:is_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[iI]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[sS]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(IsKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:is_keyword][start_index] = r0

      r0
    end

    module LevelKeyword0
    end

    def _nt_level_keyword
      start_index = index
      if node_cache[:level_keyword].has_key?(index)
        cached = node_cache[:level_keyword][index]
        if cached
          node_cache[:level_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[vV]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[lL]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(LevelKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:level_keyword][start_index] = r0

      r0
    end

    module LikeKeyword0
    end

    def _nt_like_keyword
      start_index = index
      if node_cache[:like_keyword].has_key?(index)
        cached = node_cache[:like_keyword][index]
        if cached
          node_cache[:like_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[kK]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(LikeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:like_keyword][start_index] = r0

      r0
    end

    module Like2Keyword0
    end

    def _nt_like2_keyword
      start_index = index
      if node_cache[:like2_keyword].has_key?(index)
        cached = node_cache[:like2_keyword][index]
        if cached
          node_cache[:like2_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[kK]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if (match_len = has_terminal?('2', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'2\'')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(Like2Keyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:like2_keyword][start_index] = r0

      r0
    end

    module Like4Keyword0
    end

    def _nt_like4_keyword
      start_index = index
      if node_cache[:like4_keyword].has_key?(index)
        cached = node_cache[:like4_keyword][index]
        if cached
          node_cache[:like4_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[kK]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if (match_len = has_terminal?('4', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'4\'')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(Like4Keyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:like4_keyword][start_index] = r0

      r0
    end

    module LikecKeyword0
    end

    def _nt_likec_keyword
      start_index = index
      if node_cache[:likec_keyword].has_key?(index)
        cached = node_cache[:likec_keyword][index]
        if cached
          node_cache[:likec_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[kK]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[cC]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(LikecKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:likec_keyword][start_index] = r0

      r0
    end

    module LockKeyword0
    end

    def _nt_lock_keyword
      start_index = index
      if node_cache[:lock_keyword].has_key?(index)
        cached = node_cache[:lock_keyword][index]
        if cached
          node_cache[:lock_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[kK]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(LockKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lock_keyword][start_index] = r0

      r0
    end

    module LongKeyword0
    end

    def _nt_long_keyword
      start_index = index
      if node_cache[:long_keyword].has_key?(index)
        cached = node_cache[:long_keyword][index]
        if cached
          node_cache[:long_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[lL]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[nN]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[gG]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(LongKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:long_keyword][start_index] = r0

      r0
    end

    module MaxextentsKeyword0
    end

    def _nt_maxextents_keyword
      start_index = index
      if node_cache[:maxextents_keyword].has_key?(index)
        cached = node_cache[:maxextents_keyword][index]
        if cached
          node_cache[:maxextents_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[mM]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[xX]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[xX]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[tT]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[nN]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[tT]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[sS]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          i11 = index
                          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[A-Za-z0-9]')
                            r12 = nil
                          end
                          if r12
                            @index = i11
                            r11 = nil
                            terminal_parse_failure('[A-Za-z0-9]', true)
                          else
                            terminal_failures.pop
                            @index = i11
                            r11 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(MaxextentsKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:maxextents_keyword][start_index] = r0

      r0
    end

    module MinusKeyword0
    end

    def _nt_minus_keyword
      start_index = index
      if node_cache[:minus_keyword].has_key?(index)
        cached = node_cache[:minus_keyword][index]
        if cached
          node_cache[:minus_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[mM]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[nN]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[sS]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(MinusKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:minus_keyword][start_index] = r0

      r0
    end

    module MlslabelKeyword0
    end

    def _nt_mlslabel_keyword
      start_index = index
      if node_cache[:mlslabel_keyword].has_key?(index)
        cached = node_cache[:mlslabel_keyword][index]
        if cached
          node_cache[:mlslabel_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[mM]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[lL]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[aA]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[bB]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[lL]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(MlslabelKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:mlslabel_keyword][start_index] = r0

      r0
    end

    module ModeKeyword0
    end

    def _nt_mode_keyword
      start_index = index
      if node_cache[:mode_keyword].has_key?(index)
        cached = node_cache[:mode_keyword][index]
        if cached
          node_cache[:mode_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[mM]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ModeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:mode_keyword][start_index] = r0

      r0
    end

    module ModifyKeyword0
    end

    def _nt_modify_keyword
      start_index = index
      if node_cache[:modify_keyword].has_key?(index)
        cached = node_cache[:modify_keyword][index]
        if cached
          node_cache[:modify_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[mM]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[fF]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[yY]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ModifyKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:modify_keyword][start_index] = r0

      r0
    end

    module NestedTableIdKeyword0
    end

    def _nt_nested_table_id_keyword
      start_index = index
      if node_cache[:nested_table_id_keyword].has_key?(index)
        cached = node_cache[:nested_table_id_keyword][index]
        if cached
          node_cache[:nested_table_id_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[tT]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[dD]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if (match_len = has_terminal?('_', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'_\'')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[tT]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[aA]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[bB]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                            r11 = true
                            @index += 1
                          else
                            terminal_parse_failure('[lL]')
                            r11 = nil
                          end
                          s0 << r11
                          if r11
                            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                              r12 = true
                              @index += 1
                            else
                              terminal_parse_failure('[eE]')
                              r12 = nil
                            end
                            s0 << r12
                            if r12
                              if (match_len = has_terminal?('_', false, index))
                                r13 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\'_\'')
                                r13 = nil
                              end
                              s0 << r13
                              if r13
                                if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                                  r14 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[iI]')
                                  r14 = nil
                                end
                                s0 << r14
                                if r14
                                  if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                                    r15 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[dD]')
                                    r15 = nil
                                  end
                                  s0 << r15
                                  if r15
                                    i16 = index
                                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                                      r17 = true
                                      @index += 1
                                    else
                                      terminal_parse_failure('[A-Za-z0-9]')
                                      r17 = nil
                                    end
                                    if r17
                                      @index = i16
                                      r16 = nil
                                      terminal_parse_failure('[A-Za-z0-9]', true)
                                    else
                                      terminal_failures.pop
                                      @index = i16
                                      r16 = instantiate_node(SyntaxNode,input, index...index)
                                    end
                                    s0 << r16
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NestedTableIdKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:nested_table_id_keyword][start_index] = r0

      r0
    end

    module NoauditKeyword0
    end

    def _nt_noaudit_keyword
      start_index = index
      if node_cache[:noaudit_keyword].has_key?(index)
        cached = node_cache[:noaudit_keyword][index]
        if cached
          node_cache[:noaudit_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[dD]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[iI]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NoauditKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:noaudit_keyword][start_index] = r0

      r0
    end

    module NocompressKeyword0
    end

    def _nt_nocompress_keyword
      start_index = index
      if node_cache[:nocompress_keyword].has_key?(index)
        cached = node_cache[:nocompress_keyword][index]
        if cached
          node_cache[:nocompress_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[pP]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[eE]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[sS]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[sS]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          i11 = index
                          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[A-Za-z0-9]')
                            r12 = nil
                          end
                          if r12
                            @index = i11
                            r11 = nil
                            terminal_parse_failure('[A-Za-z0-9]', true)
                          else
                            terminal_failures.pop
                            @index = i11
                            r11 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NocompressKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:nocompress_keyword][start_index] = r0

      r0
    end

    module NotKeyword0
    end

    def _nt_not_keyword
      start_index = index
      if node_cache[:not_keyword].has_key?(index)
        cached = node_cache[:not_keyword][index]
        if cached
          node_cache[:not_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NotKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:not_keyword][start_index] = r0

      r0
    end

    module NowaitKeyword0
    end

    def _nt_nowait_keyword
      start_index = index
      if node_cache[:nowait_keyword].has_key?(index)
        cached = node_cache[:nowait_keyword][index]
        if cached
          node_cache[:nowait_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[tT]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NowaitKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:nowait_keyword][start_index] = r0

      r0
    end

    module NullKeyword0
    end

    def _nt_null_keyword
      start_index = index
      if node_cache[:null_keyword].has_key?(index)
        cached = node_cache[:null_keyword][index]
        if cached
          node_cache[:null_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NullKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:null_keyword][start_index] = r0

      r0
    end

    module NumberKeyword0
    end

    def _nt_number_keyword
      start_index = index
      if node_cache[:number_keyword].has_key?(index)
        cached = node_cache[:number_keyword][index]
        if cached
          node_cache[:number_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[nN]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[mM]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[bB]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[rR]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(NumberKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:number_keyword][start_index] = r0

      r0
    end

    module OfKeyword0
    end

    def _nt_of_keyword
      start_index = index
      if node_cache[:of_keyword].has_key?(index)
        cached = node_cache[:of_keyword][index]
        if cached
          node_cache[:of_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[fF]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OfKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:of_keyword][start_index] = r0

      r0
    end

    module OfflineKeyword0
    end

    def _nt_offline_keyword
      start_index = index
      if node_cache[:offline_keyword].has_key?(index)
        cached = node_cache[:offline_keyword][index]
        if cached
          node_cache[:offline_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[fF]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[fF]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OfflineKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:offline_keyword][start_index] = r0

      r0
    end

    module OnKeyword0
    end

    def _nt_on_keyword
      start_index = index
      if node_cache[:on_keyword].has_key?(index)
        cached = node_cache[:on_keyword][index]
        if cached
          node_cache[:on_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OnKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:on_keyword][start_index] = r0

      r0
    end

    module OnlineKeyword0
    end

    def _nt_online_keyword
      start_index = index
      if node_cache[:online_keyword].has_key?(index)
        cached = node_cache[:online_keyword][index]
        if cached
          node_cache[:online_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[nN]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OnlineKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:online_keyword][start_index] = r0

      r0
    end

    module OptionKeyword0
    end

    def _nt_option_keyword
      start_index = index
      if node_cache[:option_keyword].has_key?(index)
        cached = node_cache[:option_keyword][index]
        if cached
          node_cache[:option_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[pP]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[oO]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[nN]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OptionKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:option_keyword][start_index] = r0

      r0
    end

    module OrKeyword0
    end

    def _nt_or_keyword
      start_index = index
      if node_cache[:or_keyword].has_key?(index)
        cached = node_cache[:or_keyword][index]
        if cached
          node_cache[:or_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OrKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:or_keyword][start_index] = r0

      r0
    end

    module OrderKeyword0
    end

    def _nt_order_keyword
      start_index = index
      if node_cache[:order_keyword].has_key?(index)
        cached = node_cache[:order_keyword][index]
        if cached
          node_cache[:order_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[oO]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(OrderKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:order_keyword][start_index] = r0

      r0
    end

    module PctfreeKeyword0
    end

    def _nt_pctfree_keyword
      start_index = index
      if node_cache[:pctfree_keyword].has_key?(index)
        cached = node_cache[:pctfree_keyword][index]
        if cached
          node_cache[:pctfree_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[pP]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[cC]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[fF]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(PctfreeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:pctfree_keyword][start_index] = r0

      r0
    end

    module PriorKeyword0
    end

    def _nt_prior_keyword
      start_index = index
      if node_cache[:prior_keyword].has_key?(index)
        cached = node_cache[:prior_keyword][index]
        if cached
          node_cache[:prior_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[pP]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[rR]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(PriorKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:prior_keyword][start_index] = r0

      r0
    end

    module PrivilegesKeyword0
    end

    def _nt_privileges_keyword
      start_index = index
      if node_cache[:privileges_keyword].has_key?(index)
        cached = node_cache[:privileges_keyword][index]
        if cached
          node_cache[:privileges_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[pP]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[vV]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[lL]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[gG]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[eE]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[sS]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          i11 = index
                          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[A-Za-z0-9]')
                            r12 = nil
                          end
                          if r12
                            @index = i11
                            r11 = nil
                            terminal_parse_failure('[A-Za-z0-9]', true)
                          else
                            terminal_failures.pop
                            @index = i11
                            r11 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(PrivilegesKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:privileges_keyword][start_index] = r0

      r0
    end

    module PublicKeyword0
    end

    def _nt_public_keyword
      start_index = index
      if node_cache[:public_keyword].has_key?(index)
        cached = node_cache[:public_keyword][index]
        if cached
          node_cache[:public_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[pP]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[bB]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[cC]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(PublicKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:public_keyword][start_index] = r0

      r0
    end

    module RawKeyword0
    end

    def _nt_raw_keyword
      start_index = index
      if node_cache[:raw_keyword].has_key?(index)
        cached = node_cache[:raw_keyword][index]
        if cached
          node_cache[:raw_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RawKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:raw_keyword][start_index] = r0

      r0
    end

    module RegexpLikeKeyword0
    end

    def _nt_regexp_like_keyword
      start_index = index
      if node_cache[:regexp_like_keyword].has_key?(index)
        cached = node_cache[:regexp_like_keyword][index]
        if cached
          node_cache[:regexp_like_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[gG]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[xX]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[xX]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[pP]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if (match_len = has_terminal?('_', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'_\'')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[lL]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[iI]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[kK]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                            r11 = true
                            @index += 1
                          else
                            terminal_parse_failure('[eE]')
                            r11 = nil
                          end
                          s0 << r11
                          if r11
                            i12 = index
                            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r13 = true
                              @index += 1
                            else
                              terminal_parse_failure('[A-Za-z0-9]')
                              r13 = nil
                            end
                            if r13
                              @index = i12
                              r12 = nil
                              terminal_parse_failure('[A-Za-z0-9]', true)
                            else
                              terminal_failures.pop
                              @index = i12
                              r12 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s0 << r12
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RegexpLikeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:regexp_like_keyword][start_index] = r0

      r0
    end

    module RenameKeyword0
    end

    def _nt_rename_keyword
      start_index = index
      if node_cache[:rename_keyword].has_key?(index)
        cached = node_cache[:rename_keyword][index]
        if cached
          node_cache[:rename_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[nN]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RenameKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:rename_keyword][start_index] = r0

      r0
    end

    module ResourceKeyword0
    end

    def _nt_resource_keyword
      start_index = index
      if node_cache[:resource_keyword].has_key?(index)
        cached = node_cache[:resource_keyword][index]
        if cached
          node_cache[:resource_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[uU]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[rR]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[cC]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[eE]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ResourceKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:resource_keyword][start_index] = r0

      r0
    end

    module RevokeKeyword0
    end

    def _nt_revoke_keyword
      start_index = index
      if node_cache[:revoke_keyword].has_key?(index)
        cached = node_cache[:revoke_keyword][index]
        if cached
          node_cache[:revoke_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[vV]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[kK]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[kK]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RevokeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:revoke_keyword][start_index] = r0

      r0
    end

    module RowKeyword0
    end

    def _nt_row_keyword
      start_index = index
      if node_cache[:row_keyword].has_key?(index)
        cached = node_cache[:row_keyword][index]
        if cached
          node_cache[:row_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RowKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:row_keyword][start_index] = r0

      r0
    end

    module RowidKeyword0
    end

    def _nt_rowid_keyword
      start_index = index
      if node_cache[:rowid_keyword].has_key?(index)
        cached = node_cache[:rowid_keyword][index]
        if cached
          node_cache[:rowid_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[dD]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RowidKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:rowid_keyword][start_index] = r0

      r0
    end

    module RownumKeyword0
    end

    def _nt_rownum_keyword
      start_index = index
      if node_cache[:rownum_keyword].has_key?(index)
        cached = node_cache[:rownum_keyword][index]
        if cached
          node_cache[:rownum_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[uU]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[mM]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RownumKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:rownum_keyword][start_index] = r0

      r0
    end

    module RowsKeyword0
    end

    def _nt_rows_keyword
      start_index = index
      if node_cache[:rows_keyword].has_key?(index)
        cached = node_cache[:rows_keyword][index]
        if cached
          node_cache[:rows_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[rR]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[wW]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[sS]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(RowsKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:rows_keyword][start_index] = r0

      r0
    end

    module SelectKeyword0
    end

    def _nt_select_keyword
      start_index = index
      if node_cache[:select_keyword].has_key?(index)
        cached = node_cache[:select_keyword][index]
        if cached
          node_cache[:select_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[cC]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[tT]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SelectKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:select_keyword][start_index] = r0

      r0
    end

    module SessionKeyword0
    end

    def _nt_session_keyword
      start_index = index
      if node_cache[:session_keyword].has_key?(index)
        cached = node_cache[:session_keyword][index]
        if cached
          node_cache[:session_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[sS]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[iI]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[oO]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[nN]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SessionKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:session_keyword][start_index] = r0

      r0
    end

    module SetKeyword0
    end

    def _nt_set_keyword
      start_index = index
      if node_cache[:set_keyword].has_key?(index)
        cached = node_cache[:set_keyword][index]
        if cached
          node_cache[:set_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[tT]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SetKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:set_keyword][start_index] = r0

      r0
    end

    module ShareKeyword0
    end

    def _nt_share_keyword
      start_index = index
      if node_cache[:share_keyword].has_key?(index)
        cached = node_cache[:share_keyword][index]
        if cached
          node_cache[:share_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ShareKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:share_keyword][start_index] = r0

      r0
    end

    module SizeKeyword0
    end

    def _nt_size_keyword
      start_index = index
      if node_cache[:size_keyword].has_key?(index)
        cached = node_cache[:size_keyword][index]
        if cached
          node_cache[:size_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[zZ]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[zZ]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[eE]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SizeKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:size_keyword][start_index] = r0

      r0
    end

    module SmallintKeyword0
    end

    def _nt_smallint_keyword
      start_index = index
      if node_cache[:smallint_keyword].has_key?(index)
        cached = node_cache[:smallint_keyword][index]
        if cached
          node_cache[:smallint_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[mM]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[lL]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[iI]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[nN]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[tT]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SmallintKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:smallint_keyword][start_index] = r0

      r0
    end

    module StartKeyword0
    end

    def _nt_start_keyword
      start_index = index
      if node_cache[:start_keyword].has_key?(index)
        cached = node_cache[:start_keyword][index]
        if cached
          node_cache[:start_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[tT]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[aA]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(StartKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:start_keyword][start_index] = r0

      r0
    end

    module SuccessfulKeyword0
    end

    def _nt_successful_keyword
      start_index = index
      if node_cache[:successful_keyword].has_key?(index)
        cached = node_cache[:successful_keyword][index]
        if cached
          node_cache[:successful_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[uU]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[cC]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[cC]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[sS]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[fF]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[fF]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[uU]')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
                          r10 = true
                          @index += 1
                        else
                          terminal_parse_failure('[lL]')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          i11 = index
                          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[A-Za-z0-9]')
                            r12 = nil
                          end
                          if r12
                            @index = i11
                            r11 = nil
                            terminal_parse_failure('[A-Za-z0-9]', true)
                          else
                            terminal_failures.pop
                            @index = i11
                            r11 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SuccessfulKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:successful_keyword][start_index] = r0

      r0
    end

    module SynonymKeyword0
    end

    def _nt_synonym_keyword
      start_index = index
      if node_cache[:synonym_keyword].has_key?(index)
        cached = node_cache[:synonym_keyword][index]
        if cached
          node_cache[:synonym_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[yY]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[nN]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[nN]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[yY]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[mM]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SynonymKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:synonym_keyword][start_index] = r0

      r0
    end

    module SysdateKeyword0
    end

    def _nt_sysdate_keyword
      start_index = index
      if node_cache[:sysdate_keyword].has_key?(index)
        cached = node_cache[:sysdate_keyword][index]
        if cached
          node_cache[:sysdate_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[sS]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[yY]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[sS]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[dD]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[aA]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[tT]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(SysdateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:sysdate_keyword][start_index] = r0

      r0
    end

    module TableKeyword0
    end

    def _nt_table_keyword
      start_index = index
      if node_cache[:table_keyword].has_key?(index)
        cached = node_cache[:table_keyword][index]
        if cached
          node_cache[:table_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[tT]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[bB]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[bB]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[lL]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(TableKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:table_keyword][start_index] = r0

      r0
    end

    module ThenKeyword0
    end

    def _nt_then_keyword
      start_index = index
      if node_cache[:then_keyword].has_key?(index)
        cached = node_cache[:then_keyword][index]
        if cached
          node_cache[:then_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[tT]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ThenKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:then_keyword][start_index] = r0

      r0
    end

    module ToKeyword0
    end

    def _nt_to_keyword
      start_index = index
      if node_cache[:to_keyword].has_key?(index)
        cached = node_cache[:to_keyword][index]
        if cached
          node_cache[:to_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[tT]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[oO]')
          r2 = nil
        end
        s0 << r2
        if r2
          i3 = index
          if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[A-Za-z0-9]')
            r4 = nil
          end
          if r4
            @index = i3
            r3 = nil
            terminal_parse_failure('[A-Za-z0-9]', true)
          else
            terminal_failures.pop
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ToKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:to_keyword][start_index] = r0

      r0
    end

    module TriggerKeyword0
    end

    def _nt_trigger_keyword
      start_index = index
      if node_cache[:trigger_keyword].has_key?(index)
        cached = node_cache[:trigger_keyword][index]
        if cached
          node_cache[:trigger_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[tT]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[rR]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[gG]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[gG]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[gG]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(TriggerKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:trigger_keyword][start_index] = r0

      r0
    end

    module UidKeyword0
    end

    def _nt_uid_keyword
      start_index = index
      if node_cache[:uid_keyword].has_key?(index)
        cached = node_cache[:uid_keyword][index]
        if cached
          node_cache[:uid_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[uU]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            i4 = index
            if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[A-Za-z0-9]')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('[A-Za-z0-9]', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(UidKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:uid_keyword][start_index] = r0

      r0
    end

    module UnionKeyword0
    end

    def _nt_union_keyword
      start_index = index
      if node_cache[:union_keyword].has_key?(index)
        cached = node_cache[:union_keyword][index]
        if cached
          node_cache[:union_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[uU]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[oO]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[oO]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[nN]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(UnionKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:union_keyword][start_index] = r0

      r0
    end

    module UniqueKeyword0
    end

    def _nt_unique_keyword
      start_index = index
      if node_cache[:unique_keyword].has_key?(index)
        cached = node_cache[:unique_keyword][index]
        if cached
          node_cache[:unique_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[uU]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[nN]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[iI]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[qQ]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[qQ]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[uU]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(UniqueKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:unique_keyword][start_index] = r0

      r0
    end

    module UpdateKeyword0
    end

    def _nt_update_keyword
      start_index = index
      if node_cache[:update_keyword].has_key?(index)
        cached = node_cache[:update_keyword][index]
        if cached
          node_cache[:update_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[uU]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[pP]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[pP]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[dD]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[aA]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[tT]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[eE]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(UpdateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:update_keyword][start_index] = r0

      r0
    end

    module UserKeyword0
    end

    def _nt_user_keyword
      start_index = index
      if node_cache[:user_keyword].has_key?(index)
        cached = node_cache[:user_keyword][index]
        if cached
          node_cache[:user_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[uU]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[sS]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(UserKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:user_keyword][start_index] = r0

      r0
    end

    module ValidateKeyword0
    end

    def _nt_validate_keyword
      start_index = index
      if node_cache[:validate_keyword].has_key?(index)
        cached = node_cache[:validate_keyword][index]
        if cached
          node_cache[:validate_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[vV]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[iI]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[dD]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[aA]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[tT]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[tT]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[eE]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ValidateKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:validate_keyword][start_index] = r0

      r0
    end

    module ValuesKeyword0
    end

    def _nt_values_keyword
      start_index = index
      if node_cache[:values_keyword].has_key?(index)
        cached = node_cache[:values_keyword][index]
        if cached
          node_cache[:values_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[vV]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[lL]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[lL]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[uU]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[uU]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[sS]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  i7 = index
                  if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[A-Za-z0-9]')
                    r8 = nil
                  end
                  if r8
                    @index = i7
                    r7 = nil
                    terminal_parse_failure('[A-Za-z0-9]', true)
                  else
                    terminal_failures.pop
                    @index = i7
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ValuesKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:values_keyword][start_index] = r0

      r0
    end

    module VarcharKeyword0
    end

    def _nt_varchar_keyword
      start_index = index
      if node_cache[:varchar_keyword].has_key?(index)
        cached = node_cache[:varchar_keyword][index]
        if cached
          node_cache[:varchar_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[vV]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[rR]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[cC]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[hH]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[aA]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    i8 = index
                    if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[A-Za-z0-9]')
                      r9 = nil
                    end
                    if r9
                      @index = i8
                      r8 = nil
                      terminal_parse_failure('[A-Za-z0-9]', true)
                    else
                      terminal_failures.pop
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(VarcharKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:varchar_keyword][start_index] = r0

      r0
    end

    module Varchar2Keyword0
    end

    def _nt_varchar2_keyword
      start_index = index
      if node_cache[:varchar2_keyword].has_key?(index)
        cached = node_cache[:varchar2_keyword][index]
        if cached
          node_cache[:varchar2_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[vV]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[aA]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[rR]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[cC]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[cC]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[hH]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[aA]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[aA]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[rR]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if (match_len = has_terminal?('2', false, index))
                      r8 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\'2\'')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(Varchar2Keyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:varchar2_keyword][start_index] = r0

      r0
    end

    module ViewKeyword0
    end

    def _nt_view_keyword
      start_index = index
      if node_cache[:view_keyword].has_key?(index)
        cached = node_cache[:view_keyword][index]
        if cached
          node_cache[:view_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[vV]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[iI]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[iI]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[wW]')
              r4 = nil
            end
            s0 << r4
            if r4
              i5 = index
              if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[A-Za-z0-9]')
                r6 = nil
              end
              if r6
                @index = i5
                r5 = nil
                terminal_parse_failure('[A-Za-z0-9]', true)
              else
                terminal_failures.pop
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(ViewKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:view_keyword][start_index] = r0

      r0
    end

    module WheneverKeyword0
    end

    def _nt_whenever_keyword
      start_index = index
      if node_cache[:whenever_keyword].has_key?(index)
        cached = node_cache[:whenever_keyword][index]
        if cached
          node_cache[:whenever_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[wW]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[nN]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[nN]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[vV]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[vV]')
                  r6 = nil
                end
                s0 << r6
                if r6
                  if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                    r7 = true
                    @index += 1
                  else
                    terminal_parse_failure('[eE]')
                    r7 = nil
                  end
                  s0 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[rR]')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      i9 = index
                      if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r10 = true
                        @index += 1
                      else
                        terminal_parse_failure('[A-Za-z0-9]')
                        r10 = nil
                      end
                      if r10
                        @index = i9
                        r9 = nil
                        terminal_parse_failure('[A-Za-z0-9]', true)
                      else
                        terminal_failures.pop
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(WheneverKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:whenever_keyword][start_index] = r0

      r0
    end

    module WhereKeyword0
    end

    def _nt_where_keyword
      start_index = index
      if node_cache[:where_keyword].has_key?(index)
        cached = node_cache[:where_keyword][index]
        if cached
          node_cache[:where_keyword][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[wW]')
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r2 = nil
        end
        s0 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r3 = nil
          end
          s0 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[rR]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[rR]')
              r4 = nil
            end
            s0 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r5 = nil
              end
              s0 << r5
              if r5
                i6 = index
                if has_terminal?(@regexps[gr = '\A[A-Za-z0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[A-Za-z0-9]')
                  r7 = nil
                end
                if r7
                  @index = i6
                  r6 = nil
                  terminal_parse_failure('[A-Za-z0-9]', true)
                else
                  terminal_failures.pop
                  @index = i6
                  r6 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Keyword,input, i0...index, s0)
        r0.extend(WhereKeyword0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:where_keyword][start_index] = r0

      r0
    end

  end

  class OracleReservedWordParser < Treetop::Runtime::CompiledParser
    include OracleReservedWord
  end

end
