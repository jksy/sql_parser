module SqlParser::Oracle
  grammar Select
    rule select_statement
      subquery for_update_clause:for_update_clause? {
        def ast
          SqlParser::Ast::SelectStatement.new(:subquery => subquery.ast,
                                              :for_update_clause => for_update_clause.ast)
        end
      }
    end

    rule subquery
      query_block
      (
        more_queries:(
          union_keyword (space all_keyword?) /
          intersect_keyword /
          minus_keyword
        ) space? subquery )?
      order_by_clause:order_by_clause? {
        def ast
          SqlParser::Ast::Base.new(:query_block => query_block.ast,
                                   :order_by_clause => order_by_clause.ast)
        end
      }
    end

    rule query_block
      (subquery_factoring_clause:subquery_factoring_clause space)?
      select_keyword space
      hint:hint?
      mod:(modifier:(all_keyword / distinct_keyword / unique_keyword) space)?
      select_list space?
      from_keyword space?
      select_sources space?
      where_clause:where_clause? space?
      group_by_clause:group_by_clause? space?
      model_clause:model_clause? space? {
        def ast
          SqlParser::Ast::Base.new(:hint => hint.ast,
                                   :modifier => modifier.ast,
                                   :select_list => select_list.ast,
                                   :select_sources => select_sources.ast,
                                   :where_clause => where_clause.ast,
                                   :group_by_clause => group_by_clause.ast,
                                   :model_clause => model_clause.ast)

        end

        def modifier
          mod.modifier if mod.respond_to? :modifier
        end
      }
    end

    rule select_sources
      join_clause /
      '(' space? join_clause space? ')' /
      table_reference  {
        def ast
          if respond_to? :join_clause
            join_clause.ast
          else
            super
          end
        end
      }
    end

    rule join_clause
      table_reference space
      (
        outer_join_clause /
        inner_cross_join_clause {
          def ast
            super
          end
        }
      )
    end

    rule inner_cross_join_clause
      inner_join_clause /
      cross_join_clause {
        def ast
          super
        end
      }
    end

    rule inner_join_clause
      inner_keyword space? join_keyword space? table_reference space?
      (
        on_keyword space? condition /
        using_keyword space? '(' space? column_list space? ')'
      )
    end

    rule cross_join_clause
      (
        cross_keyword /
        natural_keyword (space inner_keyword)?
      ) space join_keyword space table_reference
    end

    rule column_list
      column_name (space? ',' space? column_name)*
    end

    rule outer_join_clause
      query_partition_clause?
      (
        outer_join_type space? join_keyword /
        natural_keyword space? outer_join_type? space? join_keyword
      ) space
      table_reference space
      (query_partition_clause space)?
      (
        on_keyword space? condition /
        using_keyword space '(' space? column_list space? ')'
      )
    end

    rule query_partition_clause
      'query_partition_clause' {
        def ast
          nil
        end
      }
    end

    rule outer_join_type
      (
        full_keyword /
        left_keyword /
        right_keyword
      ) (space outer_keyword)?
    end

    rule for_update_clause
      for_keyword space?
      update_keyword space?
      (of_keyword space for_update_clause_column (space? ',' space? for_update_clause_column)*)?
      (wait_keyword space? integer / nowait_keyword)?
    end

    rule for_update_clause_column
      (
        schema_name space? '.' space? table_name space? '.' space? column_name /
        table_name space? '.' space? column_name /
        space? column_name
      )
    end

    rule subquery_factoring_clause
      'subquery_factoring_clause' { # not implemented
        def ast
          nil
        end
      }
    end

    rule order_by_clause
      order_keyword space (siblings_keyword space)? by_keyword space order_by_clause_item space? (',' space? order_by_clause_item space?)*
    end

    rule order_by_clause_item
      ( expr / position / c_alias) space?
      ( asc_keyword / desc_keyword )? space?
      ( nulls_keyword space (first_keyword / last_keyword))?
    end

    rule select_list
      select_one_column more_list:( space? ',' space? c:select_one_column space? )* {
        def ast
          SqlParser::Ast::Base.new([select_one_column.ast] + more_columns.map(&:ast))
        end

        def more_columns
          more_list.elements.map{|element| element.c}
        end
      }
    end

    rule select_one_column
      ( select_table /
        expr /
        select_column
        ) {
        def ast
          super
        end
      }
    end

    rule select_table
      (table_name '.')? '*' {
        def ast
          SqlParser::Ast::Identifier.new(:name => text_value)
        end
      }
    end

    rule select_column
      sql_expression ( space ( as_keyword space )? c_alias )?  {
        def ast
          sql_expression.ast
        end
      }
    end

    # group
    rule group_by_clause
      group_keyword space by_keyword space (( expr / rollup_cube_clause / grouping_sets_clause) space?)
        (',' space? ((expr  / rollup_cube_clause / grouping_sets_clause) space?))*
      (having_keyword space condition)?
    end

    rule rollup_cube_clause
      (rollup_keyword / cube_keyword) space? '(' space? grouping_expression_list space? ')'
    end

    rule grouping_sets_clause
      'grouping_sets_clause' { # not implemented
        def ast
          nil
        end
      }
    end

    rule grouping_expression_list
      expression_list (',' expression_list)*
    end

    rule model_clause
      'model_clause' {
        def ast
          nil
        end
      }
    end
  end
end
